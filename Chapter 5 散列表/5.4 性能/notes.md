### 性能

| 操作 | 散列表-平均情况 |散列表- 最糟情况 |数组|链表|
|-|-|-|-|-|
|查找|O(1)|O(n)|O(1)|O(n)|
|插入|O(1)|O(n)|O(n)|O(1)|
|删除|O(1)|O(n)|O(n)|O(n)|

无论散列表包含一个元素还是10亿个元素，从中获取数据所需的时间都相同。数组也是常量时间，不管数组多大，从中获取一个元素的时间是相同的。在平均情况下，散列表的速度确实很快，兼具数组和链表的优点。而最糟情况下，各种操作都很慢。避开最糟情况就得避开冲突，避开冲突的两个要素：

1. 较低的填装因子；
2. 良好的散列函数。

#### 填装因子
散列表的填装因子 = 散列表包含的元素数 ÷ 位置总数

举例来说，一个包含100个元素的散列表，如果包含100个位置，那么这个散列表的填装因子为 1；如果包含 50个位置，那么填装因子为 2。填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于 0.7，就调整散列表的长度。

平均而言，即便考虑到调整散列表长度所需的时间，散列表操作所需的时间也为 O(1)。

#### 良好的散列函数
* 良好的散列函数让数组中的值均匀分布；
* 糟糕的散列函数让值扎堆，导致大量冲突。

### 练习
散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。

假设你有四个处理字符串的散列函数。

A. 不管输入是什么，都返回1。

B. 将字符串的长度用作索引。

C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推。

D. 将每个字符都映射到一个素数：a=2,b=3, c=5, d=7, e=11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为bag，则索引为(3 + 2 + 17) % 10=22 %10=2。

在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10。

#### 5.5 将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。
答：D.
#### 5.6 电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA。
答：B. D.
#### 5.7 书名到作者的映射，其中书名分别为Maus、Fun Home和Watchmen。
答：C. D. <span style="color: red">B也可以实现均匀分布</span> ，可是我有点疑问，"Fun Home" 字符串长度是 8，和"Watchmen"一样啊，怎么算实现均匀分布？

#### 算法D有什么招证明吗，我只是感觉了一下，觉得这个算法是均匀的？
前面的小节有说到，好的散列算法是让每个元素的位置尽可能随机分配，那么算法 D对于以上三题都做得不错，无需细算就感受到不同的输入带来输出的差异性挺大的。
