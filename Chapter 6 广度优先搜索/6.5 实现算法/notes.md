### 6.5 实现算法
![原理图](原理图.png)

术语“入队”和“出队”大致相当于术语“压入”和“弹出”。

#### 初版算法
```Python
'''
breadth-first search,BFS
'''

from collections import deque

def person_is_seller(name):
    return name[-1]=='m'

def bfs():
    search_queue = deque()              #创建一个队列
    search_queue += graph['you']        #将你的邻居都加入到这个搜索队列中,这是一个数组。

    while search_queue:                 #只要队列不为空
        person = search_queue.popleft() #取出其中第一个人
        if person_is_seller(person):
            print(person + " is a mango seller!")
            return True
        else:
            search_queue += graph[person]#不是芒果销售商，则将他的朋友加入队列
    return False

graph={}
graph['you']=['alice', 'bob', 'claire']
graph['bob']=['anuj', 'peggy']
graph['alice']=['peggy']
graph['claire']=['thom', 'jonny']
graph['anuj']=[]
graph['peggy']=[]
graph['thom']=[]
graph['jonny']=[]

bfs()
```

这个算法将不断执行，直到满足以下条件之一：

* 找到一位芒果销售商；
* 队列变成空的，这意味着你的人际关系网中没有芒果销售商。

Peggy 既是 Alice 的朋友又是 Bob 的朋友，因此她将被加入队列两次。但是只需检查一次，否则可能导致死循环。考虑到这点，需添加一个数组记录已经检查过的人，并添加判断对检查过的人不作检查。

### 运行时间
1. 在人际关系网中搜索芒果商，沿每条边前行，因此运行时间 O(边数)
2. 使用了队列，包含每个要检查的人。将一个人添加到队列的时间是固定的 O(1)，对每个人执行此操作的总时间 O(人数)。
3. 所以，广度优先搜索的运行时间为 O(人数 + 边数)，写作 O(V+E)，V 为顶点（vertice）数，E 为边数。

### 练习
下面的小图说明了我早晨起床后要做的事情。
<img src="题目说明.png" alt="题目说明" style="zoom:25%;" />

该图指出，我不能没刷牙就吃早餐，因此“吃早餐”依赖于“刷牙”。另一方面，洗澡不依赖于刷牙，因为我可以先洗澡再刷牙。根据这个图，可创建一个列表，指出我需要按什么顺序完成早晨起床后要做的事情：

1. 起床
2. 洗澡
3. 刷牙
4. 吃早餐

或者

1. 起床
2. 刷牙
3. 洗澡
4. 吃早餐

#### 6.3 请问下面的三个列表哪些可行、哪些不可行？
![题图6.3](题图6.3.png)

B 可行，A、C不可行。

#### 6.4 下面是一个更大的图，请根据它创建一个可行的列表。
![题图6.4](题图6.4.png)

1. 起床
2. 打包午餐
3. 刷牙
4. 锻炼
5. 洗澡
6. 穿衣服
7. 吃早餐

从某种程度上说，这种列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。这被称为拓扑排序，使用它可根据图创建一个有序列表。

假设你有一个家谱。
![家谱说明图](题目说明2.png)

这是一个图，因为它由节点（人）和边组成。其中的边从一个节点指向其父母，但所有的边都往下指。这种图被称为树。树是一种特殊的图，其中没有往后指的边。

#### 6.5 请问下面哪个图也是树？
![题图6.5](题图6.5.png)

A、C都算树。